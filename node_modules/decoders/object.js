"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exact = exact;
exports.inexact = inexact;
exports.object = object;
exports.pojo = void 0;

var _debrief = require("debrief");

var _Result = require("lemons/Result");

var _utils = require("./utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isPojo(o) {
  return o !== null && o !== undefined && _typeof(o) === 'object' && // This still seems to be the only reliable way to determine whether
  // something is a pojo... ¯\_(ツ)_/¯
  // $FlowFixMe[method-unbinding]
  Object.prototype.toString.call(o) === '[object Object]';
}

function subtract(xs, ys) {
  var result = new Set();

  var _iterator = _createForOfIteratorHelper(xs),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var x = _step.value;

      if (!ys.has(x)) {
        result.add(x);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result;
}

var pojo = function pojo(blob) {
  return isPojo(blob) ? (0, _Result.Ok)( // NOTE:
  // Since Flow 0.98, typeof o === 'object' refines to
  //     {| +[string]: mixed |}
  // instead of
  //     {| [string]: mixed |}
  //
  // For rationale, see https://github.com/facebook/flow/issues/7685.
  // In this case, we don't want to output a read-only version of
  // the object because it's up to the user of decoders to
  // determine what they want to do with the decoded output.  If they
  // want to write items into the array, that's fine!  The fastest
  // way to turn a read-only Object to a writeable one in ES6 seems
  // to be to use object-spread. (Going off this benchmark:
  // https://thecodebarbarian.com/object-assign-vs-object-spread.html)
  _objectSpread({}, blob)) : (0, _Result.Err)((0, _debrief.annotate)(blob, 'Must be an object'));
};
/**
 * Given a mapping of fields-to-decoders, builds a decoder for an object type.
 *
 * For example, given decoders for a number and a string, we can construct an
 * "object description" like so:
 *
 *   { id: number, name: string }
 *
 * Which is of type:
 *
 *   { id: Decoder<number>, name: Decoder<string> }
 *
 * Passing this to object() will produce the following return type:
 *
 *   Decoder<{ id: number, name: string }>
 *
 * Put simply: it'll "peel off" all of the nested Decoders, puts them together
 * in an object, and wraps it in a Decoder<...>.
 */


exports.pojo = pojo;

function object(mapping) {
  var known = new Set(Object.keys(mapping));
  return (0, _utils.compose)(pojo, function (blob) {
    var actual = new Set(Object.keys(blob)); // At this point, "missing" will also include all fields that may
    // validly be optional.  We'll let the underlying decoder decide and
    // remove the key from this missing set if the decoder accepts the
    // value.

    var missing = subtract(known, actual);
    var record = {};

    var fieldErrors = _objectSpread({}, null); // NOTE: We're using .keys() here over .entries(), since .entries()
    // will type the value part as "mixed"


    for (var _i = 0, _Object$keys = Object.keys(mapping); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];
      var decoder = mapping[_key];
      var rawValue = blob[_key];
      var result = decoder(rawValue);

      try {
        var value = result.unwrap();

        if (value !== undefined) {
          record[_key] = value;
        } // If this succeeded, remove the key from the missing keys
        // tracker


        missing["delete"](_key);
      } catch (ann) {
        /* istanbul ignore next */
        if (!(0, _debrief.isAnnotation)(ann)) {
          throw ann;
        } // Keep track of the annotation, but don't return just yet. We
        // want to collect more error information.


        if (rawValue === undefined) {
          // Explicitly add it to the missing set if the value is
          // undefined.  This covers explicit undefineds to be
          // treated the same as implicit undefineds (aka missing
          // keys).
          missing.add(_key);
        } else {
          fieldErrors[_key] = ann;
        }
      }
    } // Deal with errors now. There are two classes of errors we want to
    // report.  First of all, we want to report any inline errors in this
    // object.  Lastly, any fields that are missing should be annotated on
    // the outer object itself.


    var fieldsWithErrors = Object.keys(fieldErrors);

    if (fieldsWithErrors.length > 0 || missing.size > 0) {
      var err;

      if (fieldsWithErrors.length > 0) {
        var errorlist = fieldsWithErrors.map(function (k) {
          return [k, fieldErrors[k]];
        });
        err = (0, _debrief.annotateFields)(blob, errorlist);
      } else {
        err = (0, _debrief.annotate)(blob);
      }

      if (missing.size > 0) {
        var errMsg = Array.from(missing).map(function (key) {
          return "\"".concat(key, "\"");
        }).join(', ');
        var pluralized = missing.size > 1 ? 'keys' : 'key';
        err = (0, _debrief.annotate)(err, "Missing ".concat(pluralized, ": ").concat(errMsg));
      }

      return (0, _Result.Err)(err);
    }

    return (0, _Result.Ok)(record);
  });
}

function exact(mapping) {
  // Check the inputted object for any superfluous keys
  var allowed = new Set(Object.keys(mapping));
  var checked = (0, _utils.compose)(pojo, function (blob) {
    var actual = new Set(Object.keys(blob));
    var superfluous = subtract(actual, allowed);

    if (superfluous.size > 0) {
      return (0, _Result.Err)((0, _debrief.annotate)(blob, "Superfluous keys: ".concat(Array.from(superfluous).join(', '))));
    }

    return (0, _Result.Ok)(blob);
  }); // Defer to the "object" decoder for doing the real decoding work.  Since
  // we made sure there are no superfluous keys in this structure, it's now
  // safe to force-cast it to an $Exact<> type.

  var decoder = object(mapping);
  return (0, _utils.compose)(checked, decoder);
}

function inexact(mapping) {
  return (0, _utils.compose)(pojo, function (blob) {
    var allkeys = new Set(Object.keys(blob));
    var decoder = (0, _utils.map)(object(mapping), function (safepart) {
      var safekeys = new Set(Object.keys(mapping)); // To account for hard-coded keys that aren't part of the input

      var _iterator2 = _createForOfIteratorHelper(safekeys),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var k = _step2.value;
          allkeys.add(k);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var rv = {};

      var _iterator3 = _createForOfIteratorHelper(allkeys),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _k = _step3.value;

          if (safekeys.has(_k)) {
            var value = safepart[_k];

            if (value !== undefined) {
              rv[_k] = value;
            }
          } else {
            rv[_k] = blob[_k];
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return rv;
    });
    return decoder(blob);
  });
}