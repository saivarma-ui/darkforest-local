"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compose = compose;
exports.isDate = void 0;
exports.map = map;
exports.predicate = predicate;

var _debrief = require("debrief");

var _Result = require("lemons/Result");

/**
 * `x instanceof Date` checks are unreliable across stack frames (that information
 * might get lost by the JS runtime), so we'll have to reside to more runtime
 * inspection checks.
 *
 * Taken from https://stackoverflow.com/a/44198641
 */
var isDate = function isDate(value) {
  return value !== undefined && value !== null && // $FlowFixMe[method-unbinding]
  Object.prototype.toString.call(value) === '[object Date]' && !isNaN(value);
};
/**
 * Given a decoder T and a mapping function from T's to V's, returns a decoder
 * for V's.  This is useful to change the original input data.
 */


exports.isDate = isDate;

function map(decoder, mapper) {
  return compose(decoder, function (x) {
    try {
      return (0, _Result.Ok)(mapper(x));
    } catch (e) {
      return (0, _Result.Err)((0, _debrief.annotate)(x, e instanceof Error ? e.message : String(e)));
    }
  });
}
/**
 * Compose two decoders by passing the result of the first into the second.
 * The second decoder may assume as its input type the output type of the first
 * decoder (so it's not necessary to accept the typical "mixed").  This is
 * useful for "narrowing down" the checks.  For example, if you want to write
 * a decoder for positive numbers, you can compose it from an existing decoder
 * for any number, and a decoder that, assuming a number, checks if it's
 * positive.  Very often combined with the predicate() helper as the second
 * argument.
 */


function compose(decoder, next) {
  return function (blob) {
    return decoder(blob).andThen(next);
  };
}
/**
 * Factory function returning a Decoder<T>, given a predicate function that
 * accepts/rejects the input of type T.
 */


function predicate(predicate, msg) {
  return function (value) {
    return predicate(value) ? (0, _Result.Ok)(value) : (0, _Result.Err)((0, _debrief.annotate)(value, msg));
  };
}