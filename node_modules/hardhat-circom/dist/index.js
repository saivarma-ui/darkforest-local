"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TASK_CIRCOM_TEMPLATE = exports.TASK_CIRCOM = exports.PLUGIN_NAME = void 0;
const path = __importStar(require("path"));
const crypto = __importStar(require("crypto"));
const fs = __importStar(require("fs/promises"));
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const snarkjs_1 = __importDefault(require("./snarkjs"));
// @ts-ignore because they don't ship types
const circomCompiler = __importStar(require("circom"));
config_1.extendEnvironment((hre) => {
    hre.circom = circomCompiler;
    hre.snarkjs = snarkjs_1.default;
});
exports.PLUGIN_NAME = "hardhat-circom";
exports.TASK_CIRCOM = "circom";
exports.TASK_CIRCOM_TEMPLATE = "circom:template";
config_1.extendConfig((config, userConfig) => {
    const { root } = config.paths;
    const { inputBasePath, outputBasePath, ptau, circuits = [] } = userConfig.circom ?? {};
    if (circuits.length === 0) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, "Missing required circuits list, please provide via hardhat.config.js (circom.circuits) a list of circuit names to load from the inputBasePath");
    }
    if (!ptau) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, "Missing required ptau location, please provide via hardhat.config.js (circom.ptau) the location of your ptau file");
    }
    const defaultInputBasePath = path.join(root, "circuits");
    const defaultOutputBasePath = path.join(root, "circuits");
    const normalizedInputBasePath = normalize(root, inputBasePath) ?? defaultInputBasePath;
    const normalizedOutputBasePath = normalize(root, outputBasePath) ?? defaultOutputBasePath;
    const normalizedPtauPath = path.resolve(normalizedInputBasePath, ptau);
    config.circom = {
        inputBasePath: normalizedInputBasePath,
        outputBasePath: normalizedOutputBasePath,
        ptau: normalizedPtauPath,
        circuits: [],
    };
    for (const { name, beacon, circuit, input, wasm, r1cs, zkey } of circuits) {
        if (!name) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, "Missing required name field in circuits list, please provide via hardhat.config.js (circom.circuits.name)");
        }
        const circuitPath = path.resolve(normalizedInputBasePath, circuit ?? `${name}.circom`);
        const inputPath = path.resolve(normalizedInputBasePath, input ?? `${name}.json`);
        const wasmPath = path.resolve(normalizedOutputBasePath, wasm ?? `${name}.wasm`);
        const r1csPath = path.resolve(normalizedOutputBasePath, r1cs ?? `${name}.r1cs`);
        const zkeyPath = path.resolve(normalizedOutputBasePath, zkey ?? `${name}.zkey`);
        config.circom.circuits.push({
            name: name,
            beacon: beacon != null ? beacon : "0000000000000000000000000000000000000000000000000000000000000000",
            circuit: circuitPath,
            input: inputPath,
            wasm: wasmPath,
            r1cs: r1csPath,
            zkey: zkeyPath,
        });
    }
});
async function getInputJson(input) {
    const inputString = await fs.readFile(input, "utf8");
    try {
        return JSON.parse(inputString);
    }
    catch (err) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Failed to parse JSON in file: ${input}`, err);
    }
}
config_1.task(exports.TASK_CIRCOM, "compile circom circuits and template Verifier")
    .addFlag("deterministic", "enable deterministic builds (except for .wasm)")
    .addFlag("debug", "output intermediate files to artifacts directory, generally for debug")
    .setAction(circomCompile);
async function circomCompile({ deterministic, debug }, hre) {
    const debugPath = path.join(hre.config.paths.artifacts, "circom");
    if (debug) {
        await fs.mkdir(path.join(debugPath), { recursive: true });
    }
    const ptau = await fs.readFile(hre.config.circom.ptau);
    const zkeys = [];
    for (const circuit of hre.config.circom.circuits) {
        const input = await getInputJson(circuit.input);
        const r1csFastFile = { type: "mem" };
        const wasmFastFile = { type: "mem" };
        await circomCompiler.compiler(circuit.circuit, {
            wasmFileName: wasmFastFile,
            r1csFileName: r1csFastFile,
        });
        if (!r1csFastFile.data) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate r1cs for circuit named: ${circuit.name}`);
        }
        if (!wasmFastFile.data) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate wasm for circuit named: ${circuit.name}`);
        }
        if (debug) {
            await fs.writeFile(path.join(debugPath, `${circuit.name}.r1cs`), r1csFastFile.data);
            await fs.writeFile(path.join(debugPath, `${circuit.name}.wasm`), wasmFastFile.data);
        }
        const _cir = await snarkjs_1.default.r1cs.info(r1csFastFile);
        const newKeyFastFile = { type: "mem" };
        const _csHash = await snarkjs_1.default.zKey.newZKey(r1csFastFile, ptau, newKeyFastFile);
        if (!newKeyFastFile.data) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate new zkey for circuit named: ${circuit.name}`);
        }
        if (debug) {
            await fs.writeFile(path.join(debugPath, `${circuit.name}-contribution.zkey`), newKeyFastFile.data);
        }
        const beaconZkeyFastFile = { type: "mem" };
        const _contributionHash = await snarkjs_1.default.zKey.beacon(newKeyFastFile, beaconZkeyFastFile, undefined, deterministic ? circuit.beacon : crypto.randomBytes(32).toString("hex"), 10);
        if (!beaconZkeyFastFile.data) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate beacon zkey for circuit named: ${circuit.name}`);
        }
        if (debug) {
            await fs.writeFile(path.join(debugPath, `${circuit.name}.zkey`), beaconZkeyFastFile.data);
        }
        const verificationKey = await snarkjs_1.default.zKey.exportVerificationKey(beaconZkeyFastFile);
        const wtnsFastFile = { type: "mem" };
        await snarkjs_1.default.wtns.calculate(input, wasmFastFile, wtnsFastFile);
        if (!wtnsFastFile.data) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate witness for circuit named: ${circuit.name}`);
        }
        if (debug) {
            await fs.writeFile(path.join(debugPath, `${circuit.name}.wtns`), wtnsFastFile.data);
        }
        const { proof, publicSignals } = await snarkjs_1.default.groth16.prove(beaconZkeyFastFile, wtnsFastFile);
        const verified = await snarkjs_1.default.groth16.verify(verificationKey, publicSignals, proof);
        if (!verified) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Could not verify the proof for circuit named: ${circuit.name}`);
        }
        await fs.mkdir(path.dirname(circuit.wasm), { recursive: true });
        await fs.writeFile(circuit.wasm, wasmFastFile.data);
        await fs.mkdir(path.dirname(circuit.zkey), { recursive: true });
        await fs.writeFile(circuit.zkey, beaconZkeyFastFile.data);
        await fs.mkdir(path.dirname(circuit.r1cs), { recursive: true });
        await fs.writeFile(circuit.r1cs, r1csFastFile.data);
        zkeys.push({ type: "mem", name: circuit.name, data: beaconZkeyFastFile.data });
    }
    await hre.run(exports.TASK_CIRCOM_TEMPLATE, { zkeys: zkeys });
}
function normalize(basePath, userPath) {
    let normalPath;
    if (userPath === undefined) {
        return undefined;
    }
    else {
        if (path.isAbsolute(userPath)) {
            normalPath = path.normalize(userPath);
        }
        else {
            if (basePath === undefined) {
                return undefined;
            }
            // We resolve relative paths starting from the project's root.
            // Please keep this convention to avoid confusion.
            normalPath = path.normalize(path.join(basePath, userPath));
        }
    }
    return normalPath;
}
config_1.subtask(exports.TASK_CIRCOM_TEMPLATE, "template Verifier with zkeys")
    .addParam("zkeys", "array of zkey fastfiles (can be passed directly to SnarkJS)", undefined, config_1.types.any)
    .setAction(circomTemplate);
async function circomTemplate({ zkeys }, hre) {
    let finalSol = "";
    for (const zkey of zkeys) {
        const userTemplate = `
    function ${zkey.name}VerifyingKey() internal pure returns (VerifyingKey memory vk) {
      vk.alfa1 = Pairing.G1Point(<%vk_alpha1%>);
      vk.beta2 = Pairing.G2Point(<%vk_beta2%>);
      vk.gamma2 = Pairing.G2Point(<%vk_gamma2%>);
      vk.delta2 = Pairing.G2Point(<%vk_delta2%>);
      vk.IC = new Pairing.G1Point[](<%vk_ic_length%>);
    <%vk_ic_pts%>
    }

    function verify${zkey.name.charAt(0).toUpperCase() + zkey.name.slice(1)}Proof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[<%vk_input_length%>] memory input
    ) public view returns (bool) {
        uint256[] memory inputValues = new uint256[](input.length);
        for (uint256 i = 0; i < input.length; i++) {
            inputValues[i] = input[i];
        }
        return verifyProof(a, b, c, inputValues, ${zkey.name}VerifyingKey());
    }`;
        // strings are opened as relative path files, so turn into an array of bytes
        const circuitSol = await snarkjs_1.default.zKey.exportSolidityVerifier(zkey, new TextEncoder().encode(userTemplate));
        finalSol = finalSol.concat(circuitSol);
    }
    const verifierTemplatePath = path.join(__dirname, "Verifier.sol.template");
    const verifier = path.join(hre.config.paths.sources, "Verifier.sol");
    const warning = "// THIS FILE IS GENERATED BY HARDHAT-CIRCOM. DO NOT EDIT THIS FILE.\n\n";
    const template = warning + (await fs.readFile(verifierTemplatePath)).toString();
    await fs.mkdir(path.dirname(verifier), { recursive: true });
    await fs.writeFile(verifier, template.replace(/<%full_circuit%>/g, finalSol));
}
