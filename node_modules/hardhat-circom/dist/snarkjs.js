"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
// @ts-ignore because they don't ship types
const snarkjs = __importStar(require("snarkjs"));
const pluginLogger = {};
for (const level of ["debug", "info", "warn", "error"]) {
    pluginLogger[level] = debug_1.default(`hardhat-circom:${level}`);
    pluginLogger[level].log = console[level].bind(console);
}
// This is extremely fragile and could break with SnarkJS updates
// TODO: Get the logger stuff upstreamed?
// TODO: Definitely get types upstreamed
const wrappedSnark = {
    groth16: {
        fullProve: async function groth16FullProve(input, wasmFile, zkeyFileName, logger = pluginLogger) {
            return snarkjs.groth16.fullProve(input, wasmFile, zkeyFileName, logger);
        },
        prove: async function groth16Prove(zkeyFileName, witnessFileName, logger = pluginLogger) {
            return snarkjs.groth16.prove(zkeyFileName, witnessFileName, logger);
        },
        verify: async function groth16Verify(vk_verifier, publicSignals, proof, logger = pluginLogger) {
            return snarkjs.groth16.verify(vk_verifier, publicSignals, proof, logger);
        },
    },
    powersOfTau: {
        newAccumulator: async function newAccumulator(curve, power, fileName, logger = pluginLogger) {
            return snarkjs.powersOfTau.newAccumulator(curve, power, fileName, logger);
        },
        exportChallenge: async function exportChallenge(pTauFilename, challengeFilename, logger = pluginLogger) {
            return snarkjs.powersOfTau.exportChallenge(pTauFilename, challengeFilename, logger);
        },
        importResponse: async function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger = pluginLogger) {
            return snarkjs.powersOfTau.importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger);
        },
        verify: async function verify(tauFilename, logger = pluginLogger) {
            return snarkjs.powersOfTau.verify(tauFilename, logger);
        },
        challengeContribute: async function challengeContribute(curve, challengeFilename, responesFileName, entropy, logger = pluginLogger) {
            return snarkjs.powersOfTau.challengeContribute(curve, challengeFilename, responesFileName, entropy, logger);
        },
        beacon: async function beacon(oldPtauFilename, newPTauFilename, name, beaconHashStr, numIterationsExp, logger = pluginLogger) {
            return snarkjs.powersOfTau.beacon(oldPtauFilename, newPTauFilename, name, beaconHashStr, numIterationsExp, logger);
        },
        contribute: async function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger = pluginLogger) {
            return snarkjs.powersOfTau.contribute(oldPtauFilename, newPTauFilename, name, entropy, logger);
        },
        preparePhase2: async function preparePhase2(oldPtauFilename, newPTauFilename, logger = pluginLogger) {
            return snarkjs.powersOfTau.preparePhase2(oldPtauFilename, newPTauFilename, logger);
        },
        truncate: async function truncate(ptauFilename, template, logger = pluginLogger) {
            return snarkjs.powersOfTau.truncate(ptauFilename, template, logger);
        },
        convert: async function convert(oldPtauFilename, newPTauFilename, logger = pluginLogger) {
            return snarkjs.powersOfTau.convert(oldPtauFilename, newPTauFilename, logger);
        },
        exportJson: snarkjs.powersOfTau.exportJson,
    },
    r1cs: {
        print: function r1csPrint(r1cs, syms, logger = pluginLogger) {
            return snarkjs.r1cs.print(r1cs, syms, logger);
        },
        info: async function r1csInfo(r1csName, logger = pluginLogger) {
            return snarkjs.r1cs.info(r1csName, logger);
        },
        exportJson: async function r1csExportJson(r1csFileName, logger = pluginLogger) {
            return snarkjs.r1cs.exportJson(r1csFileName, logger);
        },
    },
    wtns: {
        calculate: snarkjs.wtns.calculate,
        debug: async function wtnsDebug(input, wasmFileName, wtnsFileName, symName, options, logger = pluginLogger) {
            return snarkjs.wtns.debug(input, wasmFileName, wtnsFileName, symName, options, logger);
        },
        exportJson: snarkjs.wtns.exportJson,
    },
    zKey: {
        newZKey: async function newZKey(r1csName, ptauName, zkeyName, logger = pluginLogger) {
            return snarkjs.zKey.newZKey(r1csName, ptauName, zkeyName, logger);
        },
        exportBellman: async function phase2exportMPCParams(zkeyName, mpcparamsName, logger = pluginLogger) {
            return snarkjs.zKey.exportBellman(zkeyName, mpcparamsName, logger);
        },
        importBellman: async function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger = pluginLogger) {
            return snarkjs.zKey.importBellman(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger);
        },
        verifyFromR1cs: async function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger = pluginLogger) {
            return snarkjs.zKey.verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger);
        },
        verifyFromInit: async function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger = pluginLogger) {
            return snarkjs.zKey.verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger);
        },
        contribute: async function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger = pluginLogger) {
            return snarkjs.zKey.contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger);
        },
        beacon: async function beacon$1(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger = pluginLogger) {
            return snarkjs.zKey.beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger);
        },
        exportJson: snarkjs.zKey.exportJson,
        bellmanContribute: async function bellmanContribute(curve, challengeFilename, responesFileName, entropy, logger = pluginLogger) {
            return snarkjs.zKey.bellmanContribute(curve, challengeFilename, responesFileName, entropy, logger);
        },
        exportVerificationKey: async function zkeyExportVerificationKey(zkeyName, logger = pluginLogger) {
            return snarkjs.zKey.exportVerificationKey(zkeyName, logger);
        },
        exportSolidityVerifier: async function exportSolidityVerifier(zKeyName, templateName, logger = pluginLogger) {
            return snarkjs.zKey.exportSolidityVerifier(zKeyName, templateName, logger);
        },
    },
};
exports.default = wrappedSnark;
